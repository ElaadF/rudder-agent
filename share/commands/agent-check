#!/bin/sh
# @description check if rudder agent has no problem and is running properly
# @man Check that rudder agent is working properly.
# @man - generate missing UUID
# @man - kill cfengine if there are too many processes
# @man - run cfengine if its daemon is missing
# @man - clean lock file if it is too big
# @man - check and restore init files 
# @man - check that promises have been properly copied
# @man - will sleep a random time (max half the run interval) when not run in interactive mode prior checking agent
# @man +
# @man *Options*:
# @man +
# @man *-q*: run the agent in quiet mode (display only error messages)
# @man +
# @man *-c*: run the agent without color output
# @man +
# @man *-f*: prevent sleeping in non-interactive mode

. "${BASEDIR}/../lib/common.sh"

QUIET=false
SLEEP=true

while getopts "qcf" opt; do
  case $opt in
    q)
      QUIET=true
      ;;
    c)
      clear_colors
      ;;
    f)
      SLEEP=false
      ;;
  esac
done

# Source /etc/profile to gather environment variables from the system and the user
. /etc/profile

# Do not use set -e in the check script, otherwise a failing action may prevent repairing the problem
#set -e

# Variables
BACKUP_DIR=/var/backups/rudder/

## Which database system is used in CFEngine ?
## TokyoCabinet (tcdb), Lightning MDB (lmdb)
CFENGINE_DB_EXT=lmdb

# Default variables for CFEngine binaries and disable files
RUDDER_CFE_DIR=/var/rudder/cfengine-community
ENTERPRISE_CFE_DIR=/var/cfengine
CFE_DISABLE_FILE=/opt/rudder/etc/disable-agent
UUID_FILE=/opt/rudder/etc/uuid.hive

## Paths for Rudder Server Roles
RUDDER_SERVER_ROLES=/opt/rudder/etc/server-roles.d

# Get common commands from common.sh
init_commands

# Ensure script is executed by root
MYUID=`id | cut -d\( -f2 | cut -d\) -f1`
if [ "${MYUID}" != 'root' ];then echo "You must be root"; exit; fi

# Get the value of rudder-agent run interval from file /var/rudder/cfengine-community/inputs/run_interval
if [ -f "${CFE_DIR}/inputs/run_interval" ]; then
  RUN_INTERVAL=`cat "${CFE_DIR}/inputs/run_interval"`
  # If the value is not a number, reset to 5
  if ! test "${RUN_INTERVAL}" -gt 0 2>/dev/null
  then
    RUN_INTERVAL=5
  fi
else
  # File does not exists, use default value 5
  RUN_INTERVAL=5
fi

# sleep for a random time, if not interactive
if [ ! -t 0 ]; then
 if [ "$SLEEP" = true ]; then
    # we splay on half the interval to avoid running at the same time twice the agent
    MAX_SLEEP=`expr ${RUN_INTERVAL} \* 30`
    SLEEP_DURATION=$(awk -v m="$MAX_SLEEP" 'BEGIN{print int(rand()*m)}')
    sleep $SLEEP_DURATION
  fi
fi


clean_cf_lock_files() {
  rm -f ${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT}
  rm -f ${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT}.lock
}

check_and_fix_cfengine_keys() {
  # Making sure that the permissions on the CFEngine key directory are correct...
  if [ -d ${CFE_DIR}/ppkeys ]; then
    chmod 700 ${CFE_DIR}/ppkeys
    if [ `ls ${CFE_DIR}/ppkeys | wc -l` -gt 0 ]; then
      chmod 600 ${CFE_DIR}/ppkeys/*
    fi
  fi
}

check_and_fix_cfengine_processes() {
  # If there are more than on cf-execd process, we must kill them
  # A standard kill won't kill them, so the -9 is necessary to make sure they are stopped
  # They will be restarted by the next check, if the disable file is not set
  # List the cf-execd processes running (without the path, they can be run manually)
  CF_EXECD_RUNNING=`${PS_COMMAND} | grep "${CFE_BIN_DIR}/cf-execd" | sed -e '/grep/d' | cat`
  NB_CF_EXECD_RUNNING=`echo "${CF_EXECD_RUNNING}" | sed -e '/^$/d' | wc -l`
  if [ ${NB_CF_EXECD_RUNNING} -gt 1 ]; then
    printf "WARNING: Too many instance of CFEngine cf-execd processes running. Killing them..."
    echo "${CF_EXECD_RUNNING}" | awk 'BEGIN { OFS=" "} {print $2 }' | xargs kill -9 || true
    echo " Done"
  fi

  # List the CFEngine processes running
  CF_PROCESS_RUNNING=`${PS_COMMAND} | grep -E "${CFE_BIN_DIR}/cf-(agent|execd)" | cat`
  # Count the number of processes running, filtering empty lines
  NB_CF_PROCESS_RUNNING=`echo "${CF_PROCESS_RUNNING}" | sed -e '/^$/d' | wc -l`

  # If no disable file AND no process of CFEngine from Rudder, then relaunch cf-agent with a failsafe first
  # But this is applied only on servers or nodes already initialized (policy server set)
  if [ ! -f "${CFE_DISABLE_FILE}" ] && [ "${NB_CF_PROCESS_RUNNING}" -eq 0 ]; then
    printf "WARNING: No disable file detected and no agent executor process either. Restarting agent service..."
    rudder agent stop
    rudder agent start
    echo " Done"
  fi

  CHECK_INTERVAL=`expr ${RUN_INTERVAL} \* 2`

  # Check for the age of the last update file
  # if it is older than CHECK_INTERVAL minutes, and the disable file is not defined, we
  # need to kill the lock database
  if [ ! -f "${LAST_UPDATE_FILE}" ] || [ -f "${CFE_DISABLE_FILE}" ]; then
    # Either the file ${LAST_UPDATE_FILE} is not yet present, and this node is
    # probably not accepted yet, either the file ${CFE_DISABLE_FILE} is present, so
    # the agent won't update the ${LAST_UPDATE_FILE}.
    # In both case, do nothing
    :
  elif test `find ${LAST_UPDATE_FILE} -mmin +${CHECK_INTERVAL}`; then
    printf "WARNING: The file ${LAST_UPDATE_FILE} is older than ${CHECK_INTERVAL} minutes, the agent is probably stuck. Purging the CFEngine lock database..."
    clean_cf_lock_files
    echo " Done";
  fi


  # Check for anomalous number of CFEngine processes
  # If there are more than 8 agent/executor processes, we should kill them, and purge the lock database
  if [ "${NB_CF_PROCESS_RUNNING}" -gt 8 ]; then
    printf "WARNING: Too many instance of CFEngine processes running. Killing them, and purging the CFEngine lock database..."
    echo "${CF_PROCESS_RUNNING}" | awk 'BEGIN { OFS=" "} {print -$2 }' | xargs kill -9 || true
    rudder agent stop
    rudder agent start
    clean_cf_lock_files
    echo " Done"
  fi
}

# Check the size of the cf_lock file
check_and_fix_cf_lock() {
  MAX_CF_LOCK_SIZE=10485760
  if [ -f "${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT}" ]; then

    if [ "${OS_FAMILY}" = "AIX" ]; then
      CF_LOCK_SIZE=`istat "${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT}" | grep Length | sed "s%^.*Length \([0-9]*\) bytes.*$%\1%"`
    else
      CF_LOCK_SIZE=`stat -c%s "${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT}"`
    fi

    if [ "${CF_LOCK_SIZE}" -ge "${MAX_CF_LOCK_SIZE}" ]; then
      printf "WARNING: The file ${CFE_DIR}/state/cf_lock.${CFENGINE_DB_EXT} is too big (${CF_LOCK_SIZE} bytes), purging it..."
      clean_cf_lock_files
      echo " Done"
    fi
  fi
}

check_and_fix_rudder_uuid() {

  # Default variable about UUID backup
  LATEST_BACKUPED_UUID=""
  
  # Generate a UUID if we don't have one yet
  if [ ! -f "${UUID_FILE}" ]; then
    if [ -d "${BACKUP_DIR}" ]; then
      # this will fail on aix since -v doesn't exist
      LATEST_BACKUPED_UUID=`ls -v1 ${BACKUP_DIR}uuid-*.hive | tail -n1` || true
    fi
    if [ "${LATEST_BACKUPED_UUID}" != "" ]; then
      printf "WARNING: The UUID of the node does not exist. The lastest backup (${LATEST_BACKUPED_UUID}) will be recovered..."
      ${CP_A} ${LATEST_BACKUPED_UUID} ${UUID_FILE} >/dev/null
      echo " Done"
    else
      printf "WARNING: The UUID of the node does not exist and no backup exist. A new one will be generated..."
      /opt/rudder/bin/rudder-uuidgen > ${UUID_FILE}
      echo " Done"
    fi
  else
    # UUID is valid only if it has been generetaed by uuidgen or if it is set to 'root' for policy server
    REGEX=`x="[a-f0-9][a-f0-9][a-f0-9][a-f0-9]" && echo "$x$x-$x-$x-$x-$x$x$x"`
    CHECK_UUID=`cat /opt/rudder/etc/uuid.hive | egrep "^$REGEX|^root" | wc -l`
    # If the UUID is not valid, regenerate it
    if [ ${CHECK_UUID} -ne 1 ]; then
      printf "INFO: Creating a new UUID for Rudder as the existing one is invalid..."
      # Keep a backup of UUID even if it is not valid
      mkdir -p "${BACKUP_DIR}"
      cp -f /opt/rudder/etc/uuid.hive ${BACKUP_DIR}/uuid-`date +%Y%m%d`.hive
      # Generate a new one
      /opt/rudder/bin/rudder-uuidgen > ${UUID_FILE}
      echo " Done."
    fi
  fi
}

empty() {
  [ ! -f "$1" ] || [ $(du "$1" | awk '{print $1}') = "0" ]
}

check_and_fix_inputs() {
  # if file is absent or empty there have been a problem with update
  if empty "${CFE_DIR}/inputs/common/1.0/update.cf" || empty "${CFE_DIR}/inputs/failsafe.cf" || empty "${CFE_DIR}/inputs/promises.cf" || ${CFE_BIN_DIR}/cf-promises -f failsafe.cf | grep error > /dev/null || ${CFE_BIN_DIR}/cf-promises | grep error > /dev/null
  then
    printf "ERROR: There was an error during promises update. Reseting to initial promises and updating..."
    rm -rf ${CFE_DIR}/inputs/*
    if [ -d "/opt/rudder/share/initial-promises" ] # rudder package has been properly installed
    then
      rudder agent reset
    fi
    echo " Done"
  fi
}

check_varspace() {
  # check max space available for databases and stop Rudder if there is a risk
  if [ -f ${RUDDER_SERVER_ROLES}/rudder-ldap ]; then
    if [ -d /var/rudder/ldap/ ]; then
      ldap_space=$(df /var/rudder/ldap | tail -n 1 | awk '{print $5}' | sed 's/%//')
      if [ "${ldap_space}" -gt 98 ]; then
        stop_now=1
      fi
    fi
  fi

  if [ -f ${RUDDER_SERVER_ROLES}/rudder-reports ]; then
    # Get the run path of postgresql
    PG_TABLES_PATH=$(su - postgres -c 'psql -t -c  "show data_directory;"')
    if [ -z "${PG_TABLES_PATH}" ]; then
      echo "FATAL: Cannot connect to PostgreSQL - please check its status" | logger -s
    else
      psql_space=$(df ${PG_TABLES_PATH} | tail -n 1 | awk '{print $5}' | sed 's/%//')

      # If we are using TCP, we cannot stop postgresql otherwise all infra can go down - but we can stop rudder-jetty and disable rudder agent
      use_tcp=0
      NB_TCP=$(grep -r "TCP" /var/rudder/cfengine-community/inputs/promises.cf |  wc -l)
      if [ 2 -eq "${NB_TCP}" ]; then
        use_tcp=1
      fi

      if [ "${psql_space}" -gt 98 ]; then
        stop_now=1
      fi
    fi
  fi
  if [ "${stop_now}" = 1 ]; then
    echo "FATAL: No space left on device" | logger -s
    rudder agent disable

    # in TCP, we cannot stop Postgresql, but we can stop rudder-jetty and rudder-agent
    if [ "${use_tcp}" = 1 ]; then
      echo "FATAL: Please free space for Postgresql database" | logger -s
      if [ -f ${RUDDER_SERVER_ROLES}/rudder-jetty ]; then
        service rudder-jetty stop
        echo "FATAL: Rudder has been stopped and disabled to prevent data corruption" | logger -s
      fi
      exit 1
    else
      # In UDP, we can stop everything
      if [ -f ${RUDDER_SERVER_ROLES}/rudder-server-root ]; then
        service rudder-server stop
        echo "FATAL: Rudder has been stopped and disabled to prevent data corruption" | logger -s
      else
        if [ -f ${RUDDER_SERVER_ROLES}/rudder-jetty ]; then
          service rudder-jetty stop
          echo "FATAL: Rudder Web Interface has been stopped and disabled to prevent data corruption" | logger -s
        fi
        if [ -f ${RUDDER_SERVER_ROLES}/rudder-reports ]; then
          if type systemctl >/dev/null 2>&1; then
            POSTGRESQL_SERVICE_NAME=$(systemctl list-unit-files --type service | awk -F'.' '{print $1}' | grep -E "^postgresql[0-9]*$" | tail -n 1)
          fi
          if [ -z "${POSTGRESQL_SERVICE_NAME}" ] && type chkconfig >/dev/null 2>&1; then
            POSTGRESQL_SERVICE_NAME=$(chkconfig 2>/dev/null | awk '{ print $1 }' | grep "postgresql" | tail -n 1)
          fi
          if [ -z "${POSTGRESQL_SERVICE_NAME}" ]; then
            POSTGRESQL_SERVICE_NAME=$(ls -1 /etc/init.d | grep "postgresql" | tail -n 1)
          fi

          service ${POSTGRESQL_SERVICE_NAME} stop
          echo "FATAL: PostgreSQL has been shut down to prevent data corruption" | logger -s
        fi
      fi
      exit 1
    fi

  fi
}


# Launch each check with a certain order
check_varspace
check_and_fix_rudder_uuid

# Once for rudder's cfengine
if [ -e "${RUDDER_CFE_DIR}/bin/cf-agent" ]
then
  CFE_DIR="${RUDDER_CFE_DIR}"
  CFE_BIN_DIR="${CFE_DIR}/bin"
  LAST_UPDATE_FILE="${CFE_DIR}/last_successful_inputs_update"
  NEED_INIT_FILES="true"
  check_and_fix_cfengine_keys
  check_and_fix_cfengine_processes
  check_and_fix_cf_lock
  check_and_fix_inputs
fi

# Once for enterprise cfengine, only if managed by Rudder
# We count the number of file containing "rudder"; if there are more than 3, then it's Rudder managed
if [ -e "${ENTERPRISE_CFE_DIR}/bin/cf-agent" ]
then
  CFE_DIR="${ENTERPRISE_CFE_DIR}"
  CFE_BIN_DIR="${CFE_DIR}/bin"
  LAST_UPDATE_FILE="${CFE_DIR}/last_successful_inputs_update"
  # Check number of file starting by rudder in the folder
  COUNT_RUDDER_FILE=`find ${CFE_DIR}/inputs | grep rudder | wc -l`
  if [ ${COUNT_RUDDER_FILE} -gt 3 ]
    then
    check_and_fix_cfengine_keys
    check_and_fix_cfengine_processes
    check_and_fix_cf_lock
    check_and_fix_inputs
  fi
fi

# Check if cf-execd ou cf-serverd is listening on 8080 on a server (see #13982)
if [ -f /opt/rudder/etc/server-roles.d/rudder-jetty ] && LANG=C ss -lnpt | grep "LISTEN.*:8080.*cf-"
then
  service rudder-agent restart
fi

# Since we are in set -e there was no error here
[ "$QUIET" = false ] && printf "${GREEN}ok${NORMAL}: Rudder agent check ran without errors.\n"
